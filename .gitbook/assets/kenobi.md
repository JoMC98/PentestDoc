# Kenobi

###### tags: `Try Hack Me` `Linux` `SMB` `NFS` `FTP` `SSH`
________________________

### **FLAGS:** 
    - User Flag: d0b0f3f53b6caa532a83915e19224899
    - Root Flag: 177b3cd8562289f37382721c28381f02
________________________

### **USERS:**
    - kenobi
________________________

### **PREGUNTAS BÁSICAS**

- ***Scan the machine with nmap, how many ports are open?*** 
    Son 10, pero THM solo acepta los que no son unknown (7)
    
- ***Using the nmap command above, how many shares have been found?*** 
    3

- ***Once you're connected, list the files on the share. What is the file can you see?*** 
    log.txt

- ***What port is FTP running on?*** 
    21

- ***What mount can we see?*** 
    /var
    
- ***What port is FTP running on?*** 
    1.3.5

- ***How many exploits are there for the ProFTPd running?*** 
    3

- ***What file looks particularly out of the ordinary?*** 
    /usr/bin/menu
    
- ***Run the binary, how many options appear?*** 
    3

________________________

### **ENUMERACIÓN**

1. Vemos si el host esta levantado y saber el SSOO (**Linux**: TTL <= 64)
<code>ping -c1 IP</code>

    ![](https://i.imgur.com/xHmtxLn.png)

2. Escaneamos los puertos abiertos

    - Primero vemos si va muy lento el escaneo:
    <code>nmap -p- --open -T5 -v -n IP</code>
    
            -p-		Todos los puertos
            --open 	Mostrar solos puertos abiertos
            -T5		Modo más agresivo
            -v 		Modo verbose (reporta por pantalla)
            -n		No aplicar resolución DNS
        
    - Como va lento, lanzamos este otro comando:
    <code>nmap -sS --min-rate 5000 -p- -vvv -n -Pn IP</code>
    
            -sS		Realizar un TCP SYN port scan
            --min-rate	Emitir al menos 5000 paquetes por segundo
            -Pn		No realizar Host Discovery

     - Va más rápido y encuentra los puertos 22 (SSH) y 80 (HTTP)

        ![](https://i.imgur.com/akts9Ia.png)

3. Obtenemos los servicios que corren en los puertos
<code>nmap -sC -sV -p22,80 IP</code>

    <img src="https://i.imgur.com/xwCyYzU.png" width=400/>

4. Nos centramos en el servicio SMB, por lo que dice la info de la máquina. Procedemos a enumerar los recursos compartidos por SMB con NMAP

    - ***Explicación de los puertos de SMB*:**

        ![](https://i.imgur.com/bkgVNy3.png)
        
    <code>nmap -p139,445 --script=smb-enum-shares.nse,smb-enum-users.nse IP</code>

    ![](https://i.imgur.com/j8KR8lV.png)
    
    - Podemos usar también smbclient para listar las unidades compartidas de forma anónima:

        <code>smbclient -L \\\\IP -N</code>

        ![](https://i.imgur.com/FrdQFYW.png)

5. Vemos un Disco compartido "Anonymous". Probamos a conectarnos:

    <code>smbclient //IP/Anonymous</code>
        
    ![](https://i.imgur.com/FIjxAAn.png)

    - Vemos un fichero log.txt. Lo descargamos con <code>get FILE</code>

    - También se puede descargar de forma recursiva toda la unidad compartida

        <code>smbget -R smb://IP/Anonymous</code>

        ![](https://i.imgur.com/ayeI7S0.png)

6. El fichero parece una traza de logs. Vamos a inspeccionarlo a ver si vemos algo raro.

    - Vemos información sobre una clave pública/privada **kenobi**

        ![](https://i.imgur.com/zrCLnSC.png)

        <mark>Tenemos un usuario: **kenobi**</mark>

    - Vemos información sobre el servidor de Proftpd

        ![](https://i.imgur.com/UQrcx6o.png)

    - Vemos que el servidor FTP corre con el usuario kenobi y que tiene acceso anónimo.

7. La info de la máquina nos indica que está abierto el puerto 111 para el servicio **rpcbind**. Este servicio convierte programas RPC en direcciones físicas (puertos). Cuando se arranca un servicio RPC, le indica a rpcbind la dirección en la que esta escuchando y el número de programa RPC que tiene preparado.

    - En este caso, el puerto 111 es un acceso a un NFS. Lo enumeramos con NMAP

        <code>nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount IP</code>
    
        ![](https://i.imgur.com/8LWtWXX.png)

8. Vamos a enumerar el servicio ProFTPd para ver la versión, ya que tiene muchas vulnerabilidades

    ![](https://i.imgur.com/FY4cCF4.png)

9. Buscamos exploits para esta versión de proftpd con <code>searchsploit</code>
    
    ![](https://i.imgur.com/kshqow6.png)

10. Vemos exploits con el módulo mod_copy. La info de la máquina nos indica:

    *The modcopy module implements SITE CPFR and SITE CPTO commands, which can be used to copy files/directories from one place to another on the server. Any unauthenticated client can leverage these commands to copy files from any part of the filesystem to a chosen destination.*
    
    - Copiamos la clave privada SSH del usuario **Kenobi** que habiamos visto en el *punto 6* (/home/kenobi/.ssh/id_rsa) al directorio /var/tmp que hemos visto que estaba compartido por NFS en el *punto 7*.

        ![](https://i.imgur.com/Xaw5ufy.png)

11. Seguimos las instrucciones de la máquina y montamos el directorio **/var**:

    <code>mkdir /mnt/kenobiNFS</code>
    
    <code>mount IP:/var /mnt/kenobiNFS</code>

    <code>ls -la /mnt/kenobiNFS</code>

    ![](https://i.imgur.com/NCZUZoO.png)
    
    ![](https://i.imgur.com/GGFavre.png)

    - Nos copiamos la clave privada a nuestra máquina

        <img src="https://i.imgur.com/7zxBtst.png" width=400/>


______________

### **GET A SHELL** 

Cambiamos los permisos al id_rsa con <code>chmod 400 id_rsa</code> y nos conectamos a la máquina

<code>ssh -i id_rsa USER@IP</code>

![](https://i.imgur.com/hRsoBNv.png)

____________________

### **USER FLAG**

Navegamos al home de kenobi y vemos la flag user.txt.
    
<mark>Tenemos la user flag: **d0b0f3f53b6caa532a83915e19224899**</mark>

_____________________

### **ROOT FLAG**

Vamos a intentar una escalada de privilegios en Linux siguiendo este [tutorial](https://jieliau.medium.com/privilege-escalation-on-linux-platform-8b3fbd0b1dd4)

1. En primer lugar, intentamos ver los privilegios de sudo del usuario kenobi. No puede ejecutar el comando <code>sudo -l</code> sin saber la password de kenobi.

2. Buscamos los ficheros con el SUID, SGID o sticky activo

    - ***Explicación de los bits SUID, SGID y sticky*:**

        ![](https://i.imgur.com/Bh1maQQ.png)

    <code>find / -user root -perm -4000 2>/dev/null</code>
    
    ![](https://i.imgur.com/ThWQVl0.png)

3. Nos llama la intención **/usr/bin/menu**. Vamos a ver que es ese fichero:

     <img src="https://i.imgur.com/s8b90kg.png" width=400/>
 
4. Si intentamos ver el binario, no vemos nada porque está codificado. Lo intentamos con strings para encontrar las palabras:

    ![](https://i.imgur.com/HilUI3V.png)

    - Vemos lo que hacen las 3 opciones:
        - Un **curl** sobre localhost
        - Un **uname** para sacar la versión del SSOO
        - Un **ifconfig** para sacar las interfaces de red

5. Como podemos ver, los comandos no usan el path completo, solo usan el nombre del comando. Podemos alterar nuestro PATH de forma que alguno de esos comandos sea otra cosa. De esa forma, ejecutará otra cosa con privilegios de sudo.

    - Vemos los directorios que hay en el $PATH. Entre ellos, el primero es **/home/kenobi/bin**. Podemos crear un script curl en ese directorio que despierte una shell. Al ejecutarse como root, la despierta como root.

        ![](https://i.imgur.com/Ir4ZJiZ.png)

5. Hemos escalado privilegios. Vamos al directorio **/root** a por la 2a Flag.

    <mark>Tenemos la root flag: **177b3cd8562289f37382721c28381f02**</mark>

Podemos hacer RCE creando en el directorio bin ficheros que se llamen curl, ipconfig o uname y que ejecuten los comandos que queramos.

![](https://i.imgur.com/Fd2HBAT.png)
